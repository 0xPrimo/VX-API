#pragma once
#include "MalwareHeader.h"

PKUSER_SHARED_DATA GetKUserSharedData(VOID)
{
	return (KUSER_SHARED_DATA*)0x7FFE0000;
}

PPEB GetPeb(VOID)
{
#if defined(_WIN64)
	return (PPEB)__readgsqword(0x60);
#elif define(_WIN32)
	return (PPEB)__readfsdword(0x30);
#endif
}

PPEB GetPebAlt(VOID)
{
	PTEB Teb;
#if defined(_WIN64)
	Teb = (PTEB)__readgsqword(0x30);
#elif define(_WIN32)
	Teb = (PTEB)__readfsdword(0x18);
#endif
	return (PPEB)Teb->ProcessEnvironmentBlock;
}

PRTL_USER_PROCESS_PARAMETERS GetRtlUserProcessParameters(VOID)
{
	return GetPeb()->ProcessParameters;
}

PTEB GetTeb(VOID)
{
#if defined(_WIN64)
	return (PTEB)__readgsqword(0x30);
#elif define(_WIN32)
	return (PTEB)__readfsdword(0x18);
#endif
}

HANDLE GetProcessHeapAlt(VOID)
{
	return GetPeb()->ProcessHeap;
}

BOOL RtlLoadPeHeaders(PIMAGE_DOS_HEADER* Dos, PIMAGE_NT_HEADERS* Nt, PIMAGE_FILE_HEADER* File, PIMAGE_OPTIONAL_HEADER* Optional, PBYTE* ImageBase)
{
	*Dos = (PIMAGE_DOS_HEADER)*ImageBase;
	if ((*Dos)->e_magic != IMAGE_DOS_SIGNATURE)
		return FALSE;

	*Nt = (PIMAGE_NT_HEADERS)((PBYTE)*Dos + (*Dos)->e_lfanew);
	if ((*Nt)->Signature != IMAGE_NT_SIGNATURE)
		return FALSE;

	*File = (PIMAGE_FILE_HEADER)(*ImageBase + (*Dos)->e_lfanew + sizeof(DWORD));
	*Optional = (PIMAGE_OPTIONAL_HEADER)((PBYTE)*File + sizeof(IMAGE_FILE_HEADER));

	return TRUE;
}

DWORD64 __stdcall ImportFunction(DWORD64 ModuleBase, DWORD64 Hash, DWORD Variant)
{
	PBYTE pFunctionName;
	PIMAGE_DOS_HEADER Dos;
	PIMAGE_NT_HEADERS Nt;
	PIMAGE_FILE_HEADER File;
	PIMAGE_OPTIONAL_HEADER Optional;

	RtlLoadPeHeaders(&Dos, &Nt, &File, &Optional, (PBYTE*)&ModuleBase);

	IMAGE_EXPORT_DIRECTORY* ExportTable = (PIMAGE_EXPORT_DIRECTORY)(ModuleBase + Optional->DataDirectory[0].VirtualAddress);
	PDWORD FunctionNameAddressArray = (PDWORD)((LPBYTE)ModuleBase + ExportTable->AddressOfNames);
	PDWORD FunctionAddressArray = (PDWORD)((LPBYTE)ModuleBase + ExportTable->AddressOfFunctions);
	PWORD FunctionOrdinalAddressArray = (PWORD)((LPBYTE)ModuleBase + ExportTable->AddressOfNameOrdinals);
	DWORD dwX;

	for (dwX = 0; dwX < ExportTable->NumberOfNames; dwX++)
	{
		pFunctionName = FunctionNameAddressArray[dwX] + (PBYTE)ModuleBase;
		DWORD dwFunctionHash = HashStringBasedOnVariantA(Variant, (PCHAR)pFunctionName);

		if (Hash == dwFunctionHash)
			return ((DWORD64)ModuleBase + FunctionAddressArray[FunctionOrdinalAddressArray[dwX]]);
	}

	return 0;
}

BOOL RtlInitializeNtdllFunctionsForForwards(BOOL UseAlt)
{
	PPEB Peb = (UseAlt ? GetPebAlt() : GetPeb());
	PLDR_MODULE LoaderModule = (PLDR_MODULE)((PBYTE)Peb->LoaderData->InMemoryOrderModuleList.Flink->Flink - 16);

	pfnRtlAllocateHeap = (RTLALLOCATEHEAP)ImportFunction((DWORD64)LoaderModule->BaseAddress, RTLALLOCATEHEAP_DJB2, SH_DJB2);
	pfnFreeHeap = (RTLFREEHEAP)ImportFunction((DWORD64)LoaderModule->BaseAddress, RTLFREEHEAP_DJB2, SH_DJB2);
	pfnNtClose = (NTCLOSE)ImportFunction((DWORD64)LoaderModule->BaseAddress, NTCLOSE_DJB2, SH_DJB2);

	if (!pfnRtlAllocateHeap || !pfnFreeHeap || !pfnNtClose)
		return FALSE;
	
	return TRUE;
}
